#pragma once

#include <QDebug>

/*!
 * \brief Пример использования библиотеки Boost.Intrusive (высокопроизводительные контейнеры)
 * \details
 * Boost::intrusive — это библиотека, особенно подходящая для использования в высокопроизводительных программах. Библиотека предоставляет
 * инструменты для создания навязчивых контейнеров. Эти контейнеры заменяют известные контейнеры из стандартной библиотеки.
 *
 * Плюсы:
 * - Навязчивые контейнеры не выделяют память динамически и могут повысить производительность.
 * - Интрузивные контейнеры хранят оригинальные объекты вместо копий.
 * - Интрузивные контейнеры не выдают исключений, потому что они не выделяют память и не копируют объекты.
 *
 * Их недостаток в том, что их нельзя использовать так же просто, как, например, std::list или std::set.
 *
 * Контейнеры:
 * - boost::intrusive::list
 * - boost::intrusive::slist
 * - boost::intrusive::set
 * - boost::intrusive::unordered_set
 */
class BoostIntrusive
{
private:
    BoostIntrusive() = default;
    ~BoostIntrusive() = default;

public:
    /*!
     * \brief Пример использования boost::intrusive::list
     * \details
     * Заголовочный файл - #include <boost/intrusive/list.hpp>
     *
     * boost::intrusive::list — это двусвязный список. Чтобы опользовательский класс можно было хранить в навязчивом списке,
     * он должен быть производным от класса boost::intrusive::list_base_hook. Поскольку навязчивые контейнеры не выделяют и не освобождают
     * память, объекты, хранящиеся в интрузивном контейнере, продолжают существовать после уничтожения интрузивного контейнера.
     * Поскольку удаление элементов из интрузивных контейнеров не уничтожает их автоматически, контейнеры предоставляют нестандартные расширения,
     * такие как pop_back_and_dispose().
     */
    static auto exampleBoostIntrusiveList() -> void;

    /*!
     * \brief Пример использования boost::intrusive::set
     * \details
     * Заголовочный файл - #include <boost/intrusive/set.hpp>
     *
     * boost::intrusive::list — это двусвязный список. Чтобы опользовательский класс можно было хранить в навязчивом списке,
     * он должен быть производным от класса boost::intrusive::list_base_hook. Поскольку навязчивые контейнеры не выделяют и не освобождают
     * память, объекты, хранящиеся в интрузивном контейнере, продолжают существовать после уничтожения интрузивного контейнера.
     * Поскольку удаление элементов из интрузивных контейнеров не уничтожает их автоматически, контейнеры предоставляют нестандартные расширения,
     * такие как pop_back_and_dispose().
     */
    static auto exampleBoostIntrusiveSet() -> void;
};

