#pragma once

#include <QDebug>

/*!
 * \brief Примеры использования библиотеки Boost.Range
 * \details
 * Boost.Range:
 * - Алгоритмы
 * - Адапторы
 * - Вспомогательные классы и функции
 *
 * В отличие от Boost.Algorithm, в Boost.Range не нужно передавать .begin() и .end(), а сразу контейнер. Любой контейнер, имеющий .begin() и .end()
 * может считаться диапазоном. Большинство алгоритмов из Boost.Algorithm подходит для использования диапазонов, вместо .begin() и .end().
 */
class BoostRange
{
private:
    BoostRange() = default;
    ~BoostRange() = default;

public:
    /*!
     * \brief Примеры использования алгоритмов для диапазонов
     * \details
     * Заголовочный файл - #include <boost/range/algorithm.hpp>
     *
     * Алгоритмы:
     * - adjacent_find - находит одинаковый соседний элемент из диапазона
     * - binary_search - функция проверяет, находится ли элемент, эквивалентный значению, в диапазоне [first, last]. Требования к бинарному поиску:
     * Разделение по отношению к элементу < значение.
     * - copy - функция копирует все элементы из исходного диапазона в целевой диапазон [начало, начало + расстояние (исходный массив)].
     * - copy_backward - функция копирует элементы из диапазона, определенного [first, last], в конец другого диапазона. Элементы копируются в
     * обратном порядке (последний элемент копируется первым), но их относительный порядок сохраняется. Целевой диапазон должен иметь допустимый размер,
     * иначе возникнет неопределенное поведение.
     * - count - посчитать кол-во элементов
     * - count_if - посчитать кол-во элементов с условием (в виде унарного предиката)
     * - equal - сравнивает диапазону, если разные длины, то сразу false
     * - equal_range - это версия бинарного поиска: он пытается найти значение элемента в упорядоченном диапазоне [first, last)
     * - fill - функция инициализирует все элементы массива желаемым значением диапазона
     * - fill_n - функции для заполнения поддиапазона у диапазона
     * - find - функция возвращает итератор к первому вхождению элемента в диапазоне [first, last], который сравнивает operator== (равно) с val.
     * Если в диапазоне не найден ни один элемент, функция возвращает последний из последовательности.
     * - find_end - функция возвращает итератор к последнему вхождению последовательности range2 в range1 [first, last]
     * - find_first_of - находит элемент из набора в диапазоне
     * - find_if - находит итератор первого элемента, который выполняет условие предиката
     * - for_each - функция проходит вперед по диапазону range и для каждого элемента вызывает функцию/предикат
     * - generate - функция генерирует значение для диапазона с помощью функции, т. е. присваивает значение
     * - heap_algorithm - алгоритмы диапазона для Boost.Heap (push_heap - добавить, pop_heap - убрать, make_heap - сделать heap, sort_heap - сортировать)
     * - inplace_merge - функция объединяет два последовательных отсортированных диапазона в один отсортированный диапазон
     * - lexicographical_compare - функция проверяет, меньше ли первый диапазон лексикографически, чем второй диапазон
     */
    static auto exampleBoostRangeAlgorithms() -> void;
};

