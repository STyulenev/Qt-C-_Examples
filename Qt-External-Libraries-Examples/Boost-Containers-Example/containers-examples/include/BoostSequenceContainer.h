#pragma once

#include <QDebug>

#include <boost/array.hpp>
#include <boost/container/vector.hpp>
#include <boost/container/list.hpp>
#include <boost/container/deque.hpp>

/*!
 * \brief Класс с примерами использования последовательных boost-контейнеров.
 */
class BoostSequenceContainer
{
public:
    /*!
     * \brief Пример использования Array.
     * \details
     * 1 - Статический массив с жёстко заданным количеством элементов.
     * 2 - Данные хранятся в памяти последовательно.
     * 3 - Доступ к элементу по индексу O(1), поиск перебором O(N)
     * 4 - Удаление и вставка нового элемента недоступны, только изменение существующих.
     */
    static auto exampleBoostArray() -> void;

    /*!
     * \brief Пример использования Vector.
     * \details
     * 1 - Динамический массив.
     * 1 - Данные хранятся в памяти последовательно, если последовательной памяти недостаточно вектор переписывается в другое место.
     * 2 - При переполнении, ёмкость (capacity) увеличивается в 0.5 раз (не в 2 раза, как в std::vector), а при удалении элементов не изменяется.
     * 3 - Скорость поиска перебором O(N), O(1) - если мы знаем номер элемента.
     */
    static auto exampleBoostVector() -> void;

    /*!
     * \brief Пример использования List.
     * \details
     * 1 - Хранение в виде двухсвязного списка.
     * 2 - Вставка и удаление O(1).
     * 3 - Скорость поиска O(N).
     */
    static auto exampleBoostList() -> void;

    /*!
     * \brief Пример использования Deque (Vector + List).
     * \details
     * 1 - Динамический массив двухсвязных списков.
     * 2 - Добавить элемент в начало или конец дека O(1).
     * 3 - Извлечь элемент из начала или конца дека O(1).
     * 4 - Проверить, пуст ли дек O(1).
     * 5 - В отличием от vector, deque поддерживает вставку и удаление элементов с постоянным временем в начале последовательности
     */
    static auto exampleBoostDeque() -> void;
};

